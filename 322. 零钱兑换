class Solution {
    // 动态规划
    // f[n] 表示 amount 为 n 时，银币的最少组成数量
    // 假设现在 coins 有 1, 5, 11 并且 amount 为 15
    // 取11：　cost = f(4) + 1 = 4 + 1 = 5　
    // 取5： 　cost = f(10) + 1 = 2 + 1 = 3
    // 取1： 　cost = f(14) + 1 = 4 + 1 = 5
    // 所以最终选择取 5 ，组合银币数量为 3
    public int coinChange(int[] coins, int amount) {
        if (coins.length == 0) {
            return -1;
        }
        int[] f = new int[amount + 1]; 
        f[0] = 0;
        for (int i = 1; i <= amount; i++) {
            int count = Integer.MAX_VALUE;
            // 开始遍历 coins 有的银币金额
            for (int j = 0; j < coins.length; j++) {
                if (i - coins[j] >= 0) {
                    if (f[i - coins[j]] != Integer.MAX_VALUE) {
                        count = Math.min(count, f[i - coins[j]] + 1);
                    }
                }
            }
            f[i] = count; 
        }
        return f[amount] == Integer.MAX_VALUE ? -1 : f[amount];
    }
}
